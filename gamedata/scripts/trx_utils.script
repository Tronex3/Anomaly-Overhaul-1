
-- =======================================================================================
-- Created by Tronex
-- Last modification: 2018/7/27
-- A group of utility functions to be called and used by other scripts
-- =======================================================================================

local ini = system_ini()

local clr_table = {
	["white"]  = {255, 250, 250, 250},
	["gray"]   = {255, 170, 170, 170},
	["dark"]   = {0,140,140,140},
	["blue"]   = {0,153,255,255},
	["orange"] = {255,238,153,26},
	["red"]    = {0,204,0,51},
	["purple"] = {0,93,0,116},
	["green"]  = {0,51,255,102},
	["yellow"] = {0,250,250,0}
}


function get_clr (str , code)

-- Rule: obtain specific color code as a string or table
-- Input: color name (string) , result as string or table (boolean)
-- Output: if code is true, return table | if code is false, return string 
-- Example: get_clr("blue") --> "%c[0,153,255,255]"

	local color, color_s
	if str then
		color = clr_table[str]
	else
		color = {255, 170, 170, 170}
	end
	color_s = strformat("%c[%s,%s,%s,%s]",color[1],color[2],color[3],color[4])
	
	if code then
		return color
	end
	return color_s
end


function get_item_axis (sec)

-- Rule: get item axis out of info from its section
-- Input: section of the target item (string)
-- Output: table of item's axis (x1, y1, x2, y2, width, height)

	local a = {}
		
	local inv_grid_x = ini:r_float_ex (sec,"inv_grid_x") or 0
	local inv_grid_y = ini:r_float_ex (sec,"inv_grid_y") or 0
	local inv_grid_width = ini:r_float_ex (sec,"inv_grid_width") or 0
	local inv_grid_height = ini:r_float_ex (sec,"inv_grid_height") or 0
	
	local x1 = inv_grid_x*50
	local y1 = inv_grid_y*50

	local w = inv_grid_width*50
	local h = inv_grid_height*50

	local x2 = x1 + w
	local y2 = y1 + h
	
	a.x1 = x1
	a.y1 = y1
	a.x2 = x2
	a.y2 = y2
	a.w = w
	a.h = h
	
	return a
end


function adjust_multi_item (obj , num) 

-- Rule: adjust an existing multi-use item (increase or reduce the number of uses)
-- Input: multi-use item (object) , uses adjusting (number)
-- Output: remove the input item and create new one with adjusted uses, return true if the process went good
-- Example: ( swiss_knife_6 , -1 ) --> swiss_knife_5

	local uses = system_ini():r_float_ex(obj:section(),"uses_index")
	local base = system_ini():r_string_ex(obj:section(),"uses_base")
	
	if (not uses) or (not base) or (not system_ini():section_exist(base)) then
		return false
	end
	
	if (uses + num < 1) then return end
	
	local sec = get_multi_item_section (base, uses, num)
	if (not sec) or (not system_ini():section_exist(sec)) then
		return false
	end

	local se_obj = alife_object(obj:id())
	alife():release(se_obj,true)
	alife():create(sec, db.actor:position(), db.actor:level_vertex_id(), db.actor:game_vertex_id(), db.actor:id())
	printf("TRX - adjust_multi_item | Delete old item use: " .. obj:section() .. " | Get new item use: " .. sec)
	
	return true
end


function get_multi_item_section (base , uses_1 , uses_2)

-- Rule: get a multi-use item section based on a combination of uses of its base form
-- Input: section of base multi-use item (string) , number of uses 1 , number of uses 2
-- Output: section of the new multi-use item by combining uses 1 and 2
-- Example: ( swiss_knife , 2 , 3 ) --> swiss_knife_5 [combine] | ( swiss_knife , 4 , -1 ) --> swiss_knife_3 [separate]

	if (not base) or (not uses_1) or (not uses_2) then
		return
	end
	
	-- Items with charges
	local charges = ini:r_float_ex(base,"uses_charges") or false
	if charges then
		local str = string.sub(base,1,-2) -- remove last character
		local tbl = {str}
		for i=1,charges do
			if (ini:section_exist(str .. tostring(i))) then
				tbl[#tbl+1] = str .. tostring(i)
			end
		end
		for i=1,#tbl do
			local uses_new = ini:r_float_ex(tbl[i],"uses_index")
			if (ini:r_string_ex(tbl[i],"uses_base") == base) and (uses_new == utils.round(uses_1 + uses_2, 2)) then 
				return tbl[i]
			end
		end
	
	-- Items with special section name
	elseif (string.sub(base, string.len(base)-1, string.len(base)-1) == "_") then
		local str = string.sub(base,1,-3) -- remove last 2 characters
		local tbl = {str,base}
		local n = 2
		while ini:section_exist(str .. "_" .. tostring(n)) do
			tbl[#tbl+1] = str .. "_" .. tostring(n)
			n = n + 1
		end
		for i=1,#tbl do
			local uses_new = ini:r_float_ex(tbl[i],"uses_index")
			if (ini:r_string_ex(tbl[i],"uses_base") == base) and (uses_new == utils.round(uses_1 + uses_2, 2)) then 
				return tbl[i]
			end
		end
	
	-- Everything else
	else
		uses_new = utils.round(uses_1 + uses_2, 2)
		local sec = base .. "_" .. tostring(uses_new)
		if (uses_1 == 2) and (uses_2 == -1) then
			sec = base
		end
		return sec
	end
	
	return nil
end


function collect_inv_item (sec , num , ... )

-- Rule: search and collect available objects of a specific item from player's inventory
-- Input: section of the target item , number of objects to obtain , id of items that should be excluded from the search
-- Output: a table of the obtained objects of our item

	local item_tbl = {}
	local item_finale = {}
	local p = {...}
	local allow = true
	
	if (not num) then 
		return 
	end
	
	local function search(temp, item)
		if p and (#p > 0) then
			for i=1,#p do
				if (item:id() == p[i]) then
					allow = false
				end
			end
		end
		if (item:section() == sec) and allow then
			item_tbl[#item_tbl+1] = item
			printf("TRX - collect_inv_item | found viable item: " .. item:section() .. " | id: " .. item:id())
		end
		allow = true
	end
	db.actor:iterate_inventory(search,nil)
	
	if (#item_tbl == 0) then
		return false
	end
	
	if (#item_tbl >= num) then
		for i=1,num do
			item_finale[#item_finale+1] = item_tbl[num]
		end
		return item_finale
	end
	
	return false
end

function get_nearby_campfire (dist, result)

-- Rule: search for available campfires in a radius of (dist)
-- Input: [1] searching radius in meters (float) | [2] return type (boolean)
-- Output: if a nearby campfire is found, return true or the campfire object (controlled by "result")

	for i=1,65535 do
		local se = alife_object(i)
		if se then
			local obj = level.object_by_id(se.id)
			if obj then
				local cf = obj:get_campfire()
				if cf and (obj:position():distance_to(db.actor:position()) <= dis) then
					printf("TRX - get_nearby_campfire | found campfire in a radius of: " .. obj:position():distance_to(db.actor:position()) .. " | id: " .. obj:id())
					if result then
						return obj
					else
						return true
					end
				end
			end
		end
	end
	return false
end